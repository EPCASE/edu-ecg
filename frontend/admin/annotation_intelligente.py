#!/usr/bin/env python3
"""
Composant d'annotation intelligent avec autocompl√©tion bas√©e sur l'ontologie ECG
Interface moderne avec tags cliquables et saisie pr√©dictive
"""

import streamlit as st
import json
from pathlib import Path
import sys

# Ajout des chemins pour l'ontologie
project_root = Path(__file__).parent.parent.parent
sys.path.append(str(project_root / "backend"))

try:
    from correction_engine import OntologyCorrector
    ONTOLOGY_AVAILABLE = True
except ImportError:
    ONTOLOGY_AVAILABLE = False

def load_ontology_concepts():
    """Charge les concepts de l'ontologie ECG"""
    if not ONTOLOGY_AVAILABLE:
        return []
    
    try:
        if 'ontology_concepts' not in st.session_state:
            ontology_path = project_root / "data" / "ontologie.owx"
            corrector = OntologyCorrector(str(ontology_path))
            st.session_state.ontology_concepts = corrector.get_concept_names()
            st.session_state.ontology_corrector = corrector
        
        return st.session_state.ontology_concepts
    except Exception as e:
        st.error(f"‚ùå Erreur chargement ontologie : {e}")
        return []

def filter_concepts(query, concepts_list):
    """Filtre les concepts selon la requ√™te de l'utilisateur"""
    if not query:
        return []
    
    query_lower = query.lower()
    
    # Recherche exacte d'abord
    exact_matches = [concept for concept in concepts_list 
                    if concept.lower().startswith(query_lower)]
    
    # Puis recherche partielle
    partial_matches = [concept for concept in concepts_list 
                      if query_lower in concept.lower() and concept not in exact_matches]
    
    # Limiter √† 10 suggestions max
    return (exact_matches + partial_matches)[:10]

def annotation_intelligente_admin(key_suffix="", initial_tags=None):
    """
    Interface d'annotation intelligente pour administrateur/expert
    
    Args:
        key_suffix: Suffixe pour les cl√©s Streamlit (√©viter conflits)
        initial_tags: Liste des tags initiaux √† afficher
    
    Returns:
        Liste des tags s√©lectionn√©s
    """
    
    # Initialisation
    concepts_list = load_ontology_concepts()
    if not concepts_list:
        st.warning("‚ö†Ô∏è Ontologie non disponible - mode saisie libre")
        return st.text_area("Annotation libre :", key=f"annotation_libre_{key_suffix}")
    
    # √âtat des tags s√©lectionn√©s
    tags_key = f"selected_tags_{key_suffix}"
    if tags_key not in st.session_state:
        st.session_state[tags_key] = initial_tags or []
    
    st.markdown("#### üè∑Ô∏è Annotation par mots-cl√©s intelligents")
    
    # Zone de saisie avec autocompl√©tion
    col1, col2 = st.columns([3, 1])
    
    with col1:
        # V√©rifier si on doit vider l'input
        clear_flag_key = f"clear_input_flag_{key_suffix}"
        input_value = ""
        if clear_flag_key in st.session_state and st.session_state[clear_flag_key]:
            input_value = ""
            st.session_state[clear_flag_key] = False
        
        # Input pour nouveau concept
        query = st.text_input(
            "Ajouter un concept ECG :",
            value=input_value,
            placeholder="Tapez pour rechercher dans l'ontologie...",
            key=f"concept_input_{key_suffix}",
            help="üîç Saisissez quelques lettres pour voir les suggestions de l'ontologie"
        )
        
        # Suggestions en temps r√©el
        if query:
            suggestions = filter_concepts(query, concepts_list)
            if suggestions:
                st.markdown("**üí° Suggestions :**")
                cols = st.columns(min(3, len(suggestions)))
                
                for i, suggestion in enumerate(suggestions[:6]):  # Max 6 suggestions visibles
                    with cols[i % 3]:
                        if st.button(
                            f"+ {suggestion}", 
                            key=f"add_suggestion_{suggestion}_{key_suffix}_{i}",
                            help=f"Ajouter '{suggestion}' aux annotations"
                        ):
                            if suggestion not in st.session_state[tags_key]:
                                st.session_state[tags_key].append(suggestion)
                                # Ne pas modifier l'input directement - utiliser un flag
                                st.session_state[f"clear_input_flag_{key_suffix}"] = True
                                st.rerun()
    
    with col2:
        if st.button("üóëÔ∏è Tout effacer", key=f"clear_all_{key_suffix}"):
            st.session_state[tags_key] = []
            st.rerun()
    
    # Affichage des tags s√©lectionn√©s
    if st.session_state[tags_key]:
        st.markdown("**üè∑Ô∏è Concepts annot√©s :**")
        
        # Cr√©er des colonnes pour afficher les tags
        tag_cols = st.columns(min(4, len(st.session_state[tags_key])))
        
        for i, tag in enumerate(st.session_state[tags_key]):
            with tag_cols[i % 4]:
                # Bouton-tag cliquable pour suppression
                if st.button(
                    f"‚ùå {tag}", 
                    key=f"remove_tag_{tag}_{i}_{key_suffix}",
                    help=f"Cliquer pour supprimer '{tag}'"
                ):
                    st.session_state[tags_key].remove(tag)
                    st.rerun()
    else:
        st.info("üí≠ Aucun concept s√©lectionn√©. Commencez √† taper pour voir les suggestions.")
    
    return st.session_state[tags_key]

def annotation_intelligente_etudiant(key_suffix="", max_suggestions=8):
    """
    Interface d'annotation intelligente pour √©tudiant
    Plus guid√©e et p√©dagogique
    
    Args:
        key_suffix: Suffixe pour les cl√©s Streamlit
        max_suggestions: Nombre max de suggestions √† afficher
    
    Returns:
        Liste des concepts s√©lectionn√©s par l'√©tudiant
    """
    
    concepts_list = load_ontology_concepts()
    if not concepts_list:
        st.warning("‚ö†Ô∏è Ontologie non disponible")
        return []
    
    # √âtat des r√©ponses de l'√©tudiant
    student_key = f"student_answers_{key_suffix}"
    if student_key not in st.session_state:
        st.session_state[student_key] = []
    
    st.markdown("#### üéì Votre interpr√©tation de l'ECG")
    st.caption("üí° Tapez quelques lettres et s√©lectionnez les concepts appropri√©s")
    
    # Zone de saisie √©tudiante 
    col1, col2 = st.columns([4, 1])
    
    with col1:
        # V√©rifier si on doit vider l'input √©tudiant
        clear_student_flag_key = f"clear_student_input_flag_{key_suffix}"
        student_input_value = ""
        if clear_student_flag_key in st.session_state and st.session_state[clear_student_flag_key]:
            student_input_value = ""
            st.session_state[clear_student_flag_key] = False
        
        student_query = st.text_input(
            "Que voyez-vous sur cet ECG ?",
            value=student_input_value,
            placeholder="Ex: rythrme, frequence, axe...",
            key=f"student_input_{key_suffix}",
            help="üî§ Commencez √† taper un concept m√©dical"
        )
        
        # Menu de s√©lection intelligent pour √©tudiants
        if student_query:
            suggestions = filter_concepts(student_query, concepts_list)
            if suggestions:
                st.markdown("**üéØ Concepts possibles :**")
                
                # Affichage sous forme de s√©lecteur
                selected_suggestion = st.selectbox(
                    "Choisissez le concept appropri√© :",
                    [""] + suggestions,  # Option vide en premier
                    key=f"student_select_{key_suffix}",
                    help="S√©lectionnez le concept qui correspond √† votre observation"
                )
                
                if selected_suggestion and st.button(
                    f"‚úÖ Ajouter '{selected_suggestion}'", 
                    key=f"confirm_student_{key_suffix}"
                ):
                    if selected_suggestion not in st.session_state[student_key]:
                        st.session_state[student_key].append(selected_suggestion)
                        # Utiliser un flag au lieu de modifier directement l'input
                        st.session_state[f"clear_student_input_flag_{key_suffix}"] = True
                        st.rerun()
    
    with col2:
        if st.button("üîÑ Recommencer", key=f"restart_student_{key_suffix}"):
            st.session_state[student_key] = []
            st.rerun()
    
    # Affichage des r√©ponses de l'√©tudiant
    if st.session_state[student_key]:
        st.markdown("**‚úÖ Vos observations :**")
        
        for i, answer in enumerate(st.session_state[student_key]):
            col1, col2 = st.columns([4, 1])
            with col1:
                st.success(f"ü©∫ {answer}")
            with col2:
                if st.button("‚ùå", key=f"remove_student_{i}_{key_suffix}"):
                    st.session_state[student_key].remove(answer)
                    st.rerun()
    else:
        st.info("üîç Commencez votre analyse en tapant vos premi√®res observations")
    
    return st.session_state[student_key]

def compare_annotations(expert_tags, student_tags):
    """
    Compare les annotations expertes et √©tudiantes
    Utilise l'ontologie pour un scoring intelligent
    """
    
    if not ONTOLOGY_AVAILABLE or 'ontology_corrector' not in st.session_state:
        return {"score": 0, "feedback": "Ontologie non disponible"}
    
    corrector = st.session_state.ontology_corrector
    
    # Calcul du score global
    total_score = 0
    detailed_feedback = []
    
    if not student_tags:
        return {
            "score": 0, 
            "feedback": "‚ùå Aucune r√©ponse fournie",
            "details": []
        }
    
    # Comparaison concept par concept
    for student_concept in student_tags:
        best_match_score = 0
        best_match_expert = ""
        
        for expert_concept in expert_tags:
            score = corrector.get_score(expert_concept, student_concept)
            if score > best_match_score:
                best_match_score = score
                best_match_expert = expert_concept
        
        total_score += best_match_score
        
        if best_match_score >= 80:
            detailed_feedback.append(f"‚úÖ '{student_concept}' : Excellent ({best_match_score}%)")
        elif best_match_score >= 50:
            detailed_feedback.append(f"üü° '{student_concept}' : Bien, proche de '{best_match_expert}' ({best_match_score}%)")
        else:
            detailed_feedback.append(f"‚ùå '{student_concept}' : √Ä revoir ({best_match_score}%)")
    
    # Score final
    final_score = total_score / len(student_tags) if student_tags else 0
    
    return {
        "score": round(final_score),
        "feedback": f"Score global : {round(final_score)}%",
        "details": detailed_feedback
    }

# Test du composant
if __name__ == "__main__":
    st.set_page_config(
        page_title="Test Annotation Intelligente",
        page_icon="üß†",
        layout="wide"
    )
    
    st.title("üß† Test d'Annotation Intelligente")
    
    tab1, tab2 = st.tabs(["üë®‚Äç‚öïÔ∏è Mode Expert", "üéì Mode √âtudiant"])
    
    with tab1:
        st.header("Interface Administrateur/Expert")
        expert_tags = annotation_intelligente_admin("test_admin")
        st.write("**Tags s√©lectionn√©s :**", expert_tags)
    
    with tab2:
        st.header("Interface √âtudiant")
        student_tags = annotation_intelligente_etudiant("test_student")
        st.write("**R√©ponses √©tudiant :**", student_tags)
        
        if expert_tags and student_tags:
            st.markdown("---")
            st.header("üéØ Correction Automatique")
            comparison = compare_annotations(expert_tags, student_tags)
            
            st.metric("Score", f"{comparison['score']}%")
            st.info(comparison['feedback'])
            
            for detail in comparison.get('details', []):
                st.write(detail)
