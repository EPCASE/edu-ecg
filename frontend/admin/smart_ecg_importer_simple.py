#!/usr/bin/env python3
"""
Version simplifi√©e de l'Import Intelligent ECG
Interface lin√©aire plus intuitive sans onglets
"""

import streamlit as st
import streamlit.components.v1 as components
from PIL import Image, ImageDraw
import base64
import json
import os
from pathlib import Path
import io
import uuid
from datetime import datetime

def smart_ecg_importer_simple():
    """Interface d'import ECG simplifi√©e et lin√©aire avec support multi-ECG"""
    
    st.header("üì• Import ECG Intelligent")
    
    # Mode d'import : uniquement multiple
    st.markdown("**Import Multiple : Cr√©ez un cas puis ajoutez plusieurs ECG**")
    import_multiple_workflow()


def import_multiple_workflow():
    """Workflow d'import multiple - plusieurs ECG pour un cas"""
    
    # √âtat de session pour l'import multiple
    if 'multi_case' not in st.session_state:
        st.session_state.multi_case = None
    if 'multi_ecgs' not in st.session_state:
        st.session_state.multi_ecgs = []
    
    # Interface de debug et reset en cas de probl√®me
    with st.expander("üîß Debug & Reset (si probl√®me)", expanded=False):
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.write("**√âtat actuel:**")
            if st.session_state.multi_case:
                st.write(f"- Cas: {st.session_state.multi_case['name']}")
            else:
                st.write("- Cas: Aucun")
            st.write(f"- ECG: {len(st.session_state.multi_ecgs)}")
        
        with col2:
            if st.button("üóëÔ∏è Reset complet", type="secondary"):
                st.session_state.multi_case = None
                st.session_state.multi_ecgs = []
                st.success("‚úÖ R√©initialis√© !")
                st.rerun()
        
        with col3:
            if st.button("üîÑ Rafra√Æchir page", type="secondary"):
                st.rerun()
    
    if st.session_state.multi_case is None:
        # √âtape 1 : Cr√©ation du cas
        create_multi_case_interface()
    else:
        # √âtape 2 : Gestion progressive des ECG
        st.markdown(f"### üìã Cas : **{st.session_state.multi_case['name']}**")
        
        col1, col2 = st.columns([3, 1])
        with col1:
            st.write(f"**ECG ajout√©s :** {len(st.session_state.multi_ecgs)}")
        with col2:
            if st.button("üîÑ Nouveau Cas", type="secondary"):
                if st.session_state.multi_ecgs:
                    st.warning("‚ö†Ô∏è Vous avez des ECG non sauvegard√©s !")
                    if st.button("‚úÖ Confirmer nouveau cas"):
                        st.session_state.multi_case = None
                        st.session_state.multi_ecgs = []
                        st.rerun()
                else:
                    st.session_state.multi_case = None
                    st.session_state.multi_ecgs = []
                    st.rerun()
        
        # Tabs pour les actions
        tabs = st.tabs(["üì• Ajouter ECG", "‚úÇÔ∏è Recadrer ECG", "üëÅÔ∏è Aper√ßu Final", "‚úÖ Sauvegarder"])
        
        with tabs[0]:
            add_ecg_to_multi_case()
        
        with tabs[1]:
            crop_multi_ecg_interface()
        
        with tabs[2]:
            preview_multi_case()
        
        with tabs[3]:
            save_multi_case()

def create_multi_case_interface():
    """Interface de cr√©ation d'un nouveau cas multi-ECG"""
    
    st.markdown("### üìã Cr√©er un Nouveau Cas ECG")
    
    with st.form("create_multi_case"):
        case_name = st.text_input("üìù Nom du cas", placeholder="Ex: Infarctus Ant√©rieur - Patient 45 ans")
        
        col1, col2 = st.columns(2)
        with col1:
            case_category = st.selectbox("üìÇ Cat√©gorie", [
                "Infarctus", "Arythmie", "Bloc de branche", "Normal", 
                "P√©ricardite", "Embolie pulmonaire", "Autre"
            ])
        
        with col2:
            case_difficulty = st.selectbox("üéØ Niveau", [
                "D√©butant", "Interm√©diaire", "Avanc√©", "Expert"
            ])
        
        case_description = st.text_area("üìñ Description clinique", 
                                       placeholder="Contexte du patient, histoire clinique...")
        
        submitted = st.form_submit_button("‚úÖ Cr√©er le Cas", type="primary")
        
        if submitted:
            if case_name:
                st.session_state.multi_case = {
                    'name': case_name,
                    'category': case_category,
                    'difficulty': case_difficulty,
                    'description': case_description,
                    'created_date': datetime.now().isoformat(),
                    'case_id': f"multi_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{str(uuid.uuid4())[:8]}"
                }
                st.success(f"‚úÖ Cas '{case_name}' cr√©√© !")
                st.rerun()
            else:
                st.error("‚ùå Le nom du cas est obligatoire")

def add_ecg_to_multi_case():
    """Ajouter un ECG au cas en cours"""
    
    st.markdown("### üì• Ajouter un ECG au Cas")
    
    if len(st.session_state.multi_ecgs) > 0:
        st.info(f"üìä **{len(st.session_state.multi_ecgs)} ECG** d√©j√† ajout√©s √† ce cas")
    
    uploaded_file = st.file_uploader(
        f"S√©lectionnez l'ECG #{len(st.session_state.multi_ecgs) + 1}",
        type=['pdf', 'png', 'jpg', 'jpeg'],
        key=f"upload_ecg_{len(st.session_state.multi_ecgs)}",
        help="Formats support√©s : PDF, PNG, JPG, JPEG"
    )
    
    if uploaded_file is not None:
        # Traitement du fichier
        success, file_data = process_uploaded_file(uploaded_file)
        if success and file_data:
            with st.form("ecg_metadata"):
                col1, col2 = st.columns(2)
                with col1:
                    ecg_label = st.text_input("üè∑Ô∏è Libell√©", 
                        value=f"ECG_{len(st.session_state.multi_ecgs) + 1}",
                        placeholder="Ex: ECG_Initial, ECG_Post_Traitement")
                with col2:
                    ecg_timing = st.selectbox("‚è∞ Timing", [
                        "Initial", "Contr√¥le", "Post-traitement", "Suivi", 
                        "Admission", "Sortie", "J+1", "Autre"
                    ])
                ecg_notes = st.text_area("üìù Notes", 
                    placeholder="Notes particuli√®res pour cet ECG...")

                col1, col2 = st.columns(2)
                with col1:
                    add_direct = st.form_submit_button("‚úÖ Ajouter Direct", type="primary")
                with col2:
                    add_with_crop = st.form_submit_button("‚úÇÔ∏è Ajouter + Recadrer", type="secondary")

                if add_direct or add_with_crop:
                    if ecg_label:
                        ecg_data = {
                            'file_data': file_data,
                            'label': ecg_label,
                            'timing': ecg_timing,
                            'notes': ecg_notes,
                            'annotations': [],  # annotation √† faire apr√®s
                            'filename': uploaded_file.name,
                            'added_date': datetime.now().isoformat(),
                            'needs_crop': add_with_crop,
                            'cropped': False
                        }
                        st.session_state.multi_ecgs.append(ecg_data)
                        st.session_state.pending_annotation_idx = len(st.session_state.multi_ecgs) - 1
                        st.success(f"‚úÖ ECG '{ecg_label}' ajout√© au cas !")
                        if add_with_crop:
                            st.info("üí° Passez √† l'onglet 'Recadrer ECG' pour traiter cet ECG")
                        st.rerun()
                    else:
                        st.error("‚ùå Le libell√© est obligatoire")

    # Affichage de la bo√Æte d'annotation apr√®s ajout
    if 'pending_annotation_idx' in st.session_state:
        idx = st.session_state['pending_annotation_idx']
        if 0 <= idx < len(st.session_state.multi_ecgs):
            ecg = st.session_state.multi_ecgs[idx]
            st.markdown(f"### üè∑Ô∏è Annotations pour l'ECG : **{ecg['label']}**")
            import sys
            import importlib.util
            annopath = os.path.join(os.path.dirname(__file__), '..', 'annotation_components.py')
            spec = importlib.util.spec_from_file_location("annotation_components", annopath)
            annotation_components = importlib.util.module_from_spec(spec)
            sys.modules["annotation_components"] = annotation_components
            spec.loader.exec_module(annotation_components)
            annotations = annotation_components.smart_annotation_input(
                key_prefix=f"ecg_anno_{idx}",
                max_tags=10
            )
            if st.button("‚úÖ Valider l'annotation", key=f"validate_anno_{idx}"):
                st.session_state.multi_ecgs[idx]['annotations'] = annotations
                st.success("Annotations enregistr√©es !")
                del st.session_state['pending_annotation_idx']
                st.rerun()

def crop_multi_ecg_interface():
    """Interface de recadrage pour les ECG du cas"""
    
    st.markdown("### ‚úÇÔ∏è Recadrage des ECG")
    
    # Filtrer les ECG qui ont besoin de recadrage
    ecgs_to_crop = [ecg for ecg in st.session_state.multi_ecgs if ecg.get('needs_crop', False) and not ecg.get('cropped', False)]
    
    if not ecgs_to_crop:
        if any(ecg.get('cropped', False) for ecg in st.session_state.multi_ecgs):
            st.success("‚úÖ Tous les ECG n√©cessitant un recadrage ont √©t√© trait√©s !")
        else:
            st.info("üìù Aucun ECG en attente de recadrage")
        return
    
    st.write(f"**{len(ecgs_to_crop)} ECG** en attente de recadrage")
    
    # S√©lection de l'ECG √† recadrer
    ecg_labels = [f"{ecg['label']} ({ecg['timing']})" for ecg in ecgs_to_crop]
    selected_idx = st.selectbox("Choisir l'ECG √† recadrer", range(len(ecg_labels)), 
                               format_func=lambda x: ecg_labels[x])
    
    if selected_idx is not None:
        current_ecg = ecgs_to_crop[selected_idx]
        
        st.markdown(f"#### ‚úÇÔ∏è Recadrage : {current_ecg['label']}")
        
        # Interface de recadrage (r√©utilise la fonction existante)
        if current_ecg['file_data']['type'] in ['image', 'pdf_converted']:
            cropped_data = interface_recadrage_simple(current_ecg['file_data'])
            
            if cropped_data and st.button("‚úÖ Valider le recadrage", type="primary", 
                                         key=f"validate_crop_{selected_idx}_{current_ecg['label']}"):
                # Marquer comme recadr√© et sauvegarder
                current_ecg['cropped'] = True
                current_ecg['cropped_data'] = cropped_data
                current_ecg['needs_crop'] = False
                
                st.success(f"‚úÖ ECG '{current_ecg['label']}' recadr√© avec succ√®s !")
                st.rerun()

def preview_multi_case():
    """Aper√ßu du cas complet avant sauvegarde"""
    
    st.markdown("### üëÅÔ∏è Aper√ßu du Cas Complet")
    
    if not st.session_state.multi_ecgs:
        st.warning("‚ö†Ô∏è Aucun ECG ajout√© √† ce cas")
        return
    
    # Informations du cas
    case = st.session_state.multi_case
    st.markdown(f"#### üìã {case['name']}")
    
    col1, col2, col3 = st.columns(3)
    with col1:
        st.write(f"**Cat√©gorie :** {case['category']}")
    with col2:
        st.write(f"**Niveau :** {case['difficulty']}")
    with col3:
        st.write(f"**ECG :** {len(st.session_state.multi_ecgs)}")
    
    if case['description']:
        st.write(f"**Description :** {case['description']}")
    
    st.markdown("---")
    
    # Liste des ECG
    st.markdown("#### üìÑ ECG du Cas")
    
    for i, ecg in enumerate(st.session_state.multi_ecgs):
        with st.expander(f"üìÑ {ecg['label']} - {ecg['timing']}", expanded=False):
            col1, col2 = st.columns([2, 1])
            
            with col1:
                st.write(f"**Fichier :** {ecg['filename']}")
                st.write(f"**Timing :** {ecg['timing']}")
                if ecg['notes']:
                    st.write(f"**Notes :** {ecg['notes']}")
                
                # Status
                status = "‚úÇÔ∏è Recadr√©" if ecg.get('cropped', False) else "üìÑ Original"
                st.write(f"**Status :** {status}")
            
            with col2:
                # Actions sur ECG individuel
                if st.button(f"üóëÔ∏è Supprimer", key=f"del_ecg_{i}"):
                    st.session_state.multi_ecgs.pop(i)
                    st.rerun()
                
                if not ecg.get('cropped', False):
                    if st.button(f"‚úÇÔ∏è Recadrer", key=f"crop_ecg_{i}"):
                        ecg['needs_crop'] = True
                        st.info("üí° Passez √† l'onglet 'Recadrer ECG'")

def save_multi_case():
    """Sauvegarder le cas multi-ECG complet"""
    
    st.markdown("### üíæ Sauvegarder le Cas")
    
    if not st.session_state.multi_ecgs:
        st.warning("‚ö†Ô∏è Aucun ECG √† sauvegarder")
        return
    
    case = st.session_state.multi_case
    
    # Aper√ßu final
    st.write(f"**Cas :** {case['name']}")
    st.write(f"**Nombre d'ECG :** {len(st.session_state.multi_ecgs)}")
    
    # Options de sauvegarde
    with st.form("save_multi_case"):
        st.markdown("#### ‚öôÔ∏è Options de Sauvegarde")
        
        col1, col2 = st.columns(2)
        with col1:
            generate_previews = st.checkbox("üñºÔ∏è G√©n√©rer des aper√ßus", value=True)
            create_annotations = st.checkbox("üìù Cr√©er template d'annotation", value=True)
        
        with col2:
            auto_publish = st.checkbox("üì¢ Publier automatiquement", value=False)
            create_session = st.checkbox("üéì Cr√©er session d'√©tude", value=False)
        
        if st.form_submit_button("üíæ Sauvegarder le Cas", type="primary"):
            success = save_final_multi_case(
                case, st.session_state.multi_ecgs,
                generate_previews, create_annotations, auto_publish, create_session
            )
            
            if success:
                st.success("‚úÖ Cas multi-ECG sauvegard√© avec succ√®s !")
                
                # Reset pour nouveau cas - marquer le succ√®s
                st.session_state.save_success = True
            else:
                st.error("‚ùå Erreur lors de la sauvegarde")
    
    # Bouton pour nouveau cas - en dehors du formulaire
    if st.session_state.get('save_success', False):
        if st.button("üÜï Cr√©er un Nouveau Cas"):
            st.session_state.multi_case = None
            st.session_state.multi_ecgs = []
            st.session_state.save_success = False
            st.rerun()

def save_final_multi_case(case, ecgs, generate_previews, create_annotations, auto_publish, create_session):
    """Sauvegarder effectivement le cas multi-ECG avec debugging am√©lior√©"""
    
    try:
        # Debug : afficher les informations
        st.write("üîß **Debug Sauvegarde :**")
        st.write(f"- Cas : {case['name']}")
        st.write(f"- Nombre d'ECG : {len(ecgs)}")
        st.write(f"- ID du cas : {case['case_id']}")
        
        # Cr√©er le dossier du cas
        case_dir = Path("data/ecg_cases") / case['case_id']
        st.write(f"- Cr√©ation dossier : {case_dir}")
        case_dir.mkdir(parents=True, exist_ok=True)
        
        # V√©rifier que le dossier existe
        if not case_dir.exists():
            st.error(f"‚ùå Impossible de cr√©er le dossier : {case_dir}")
            return False
        
        st.write("‚úÖ Dossier cr√©√© avec succ√®s")
        
        # M√©tadonn√©es du cas
        metadata = {
            'name': case['name'],
            'description': case['description'],
            'category': case['category'],
            'difficulty': case['difficulty'],
            'created_date': case['created_date'],
            'case_id': case['case_id'],
            'type': 'multi_ecg',
            'total_files': len(ecgs),
            'options': {
                'generate_previews': generate_previews,
                'create_annotations': create_annotations,
                'auto_publish': auto_publish,
                'create_session': create_session
            },
            'ecgs': []
        }
        
        # Traiter chaque ECG
        for i, ecg in enumerate(ecgs):
            try:
                ecg_filename = f"ecg_{i+1:02d}_{ecg['label']}.png"
                ecg_path = case_dir / ecg_filename
                
                st.write(f"- Traitement ECG {i+1}: {ecg['label']}")
                
                # V√©rifier que nous avons une image
                image = None
                if ecg.get('cropped', False) and 'cropped_data' in ecg:
                    image = ecg['cropped_data']['image']
                    st.write(f"  ‚Üí Utilisation image recadr√©e")
                elif 'file_data' in ecg and 'image' in ecg['file_data']:
                    image = ecg['file_data']['image']
                    st.write(f"  ‚Üí Utilisation image originale")
                else:
                    st.error(f"  ‚ùå Pas d'image trouv√©e pour ECG {i+1}")
                    continue
                
                # Sauvegarder l'image
                if image:
                    image.save(ecg_path, "PNG", optimize=True)
                    st.write(f"  ‚úÖ Sauv√©: {ecg_filename}")
                    
                    # V√©rifier que le fichier existe
                    if not ecg_path.exists():
                        st.error(f"  ‚ùå Fichier non cr√©√©: {ecg_filename}")
                        continue
                    
                    file_size = ecg_path.stat().st_size
                    st.write(f"  üìä Taille: {file_size // 1024} KB")
                
                # M√©tadonn√©es de l'ECG
                ecg_meta = {
                    'filename': ecg_filename,
                    'label': ecg['label'],
                    'timing': ecg['timing'],
                    'notes': ecg['notes'],
                    'original_filename': ecg['filename'],
                    'cropped': ecg.get('cropped', False),
                    'added_date': ecg['added_date']
                }
                
                metadata['ecgs'].append(ecg_meta)
                
            except Exception as ecg_error:
                st.error(f"‚ùå Erreur ECG {i+1}: {ecg_error}")
                continue
        
        # Sauvegarder les m√©tadonn√©es
        try:
            metadata_path = case_dir / "metadata.json"
            st.write(f"- Sauvegarde m√©tadonn√©es: {metadata_path}")
            
            with open(metadata_path, 'w', encoding='utf-8') as f:
                json.dump(metadata, f, indent=2, ensure_ascii=False)
            
            # V√©rifier que le fichier existe
            if metadata_path.exists():
                st.write("‚úÖ M√©tadonn√©es sauv√©es")
            else:
                st.error("‚ùå Fichier m√©tadonn√©es non cr√©√©")
                return False
                
        except Exception as meta_error:
            st.error(f"‚ùå Erreur m√©tadonn√©es: {meta_error}")
            return False
        
        # Cr√©er template d'annotation si demand√©
        if create_annotations:
            try:
                template_path = case_dir / "annotation_template.json"
                template = {
                    'case_id': case['case_id'],
                    'annotations': [],
                    'created_date': datetime.now().isoformat(),
                    'template_version': '1.0'
                }
                
                with open(template_path, 'w', encoding='utf-8') as f:
                    json.dump(template, f, indent=2, ensure_ascii=False)
                
                st.write("‚úÖ Template d'annotation cr√©√©")
                
            except Exception as template_error:
                st.warning(f"‚ö†Ô∏è Erreur template: {template_error}")
        
        # R√©sum√© final
        st.success("üéâ **Sauvegarde termin√©e avec succ√®s !**")
        st.write(f"üìÅ Dossier: {case_dir}")
        st.write(f"üìÑ ECG sauv√©s: {len(metadata['ecgs'])}")
        
        return True
        
    except Exception as e:
        st.error(f"‚ùå Erreur g√©n√©rale lors de la sauvegarde : {e}")
        import traceback
        st.code(traceback.format_exc())
        return False

def process_uploaded_file(uploaded_file):
    """Traite le fichier upload√© selon son type"""
    
    file_extension = Path(uploaded_file.name).suffix.lower()
    
    # Affichage des informations
    col1, col2 = st.columns([2, 1])
    
    with col2:
        st.markdown("#### üìä Informations")
        st.write(f"**Nom :** {uploaded_file.name}")
        st.write(f"**Type :** {file_extension.upper()}")
        st.write(f"**Taille :** {len(uploaded_file.getvalue()) / 1024:.1f} KB")
    
    with col1:
        if file_extension == '.pdf':
            return traiter_pdf_simple(uploaded_file)
        elif file_extension in ['.png', '.jpg', '.jpeg']:
            return traiter_image_simple(uploaded_file)
        elif file_extension == '.xml':
            return traiter_xml_simple(uploaded_file)
        else:
            st.error(f"‚ùå Format {file_extension} non support√©")
            return False, None

def traiter_image_simple(uploaded_file):
    """Traite les images de fa√ßon simple"""
    
    try:
        image = Image.open(uploaded_file)
        
        st.markdown("#### üñºÔ∏è Image ECG charg√©e")
        st.image(image, caption=f"ECG - {uploaded_file.name}", use_container_width=True)
        
        st.write(f"**Dimensions :** {image.size[0]} √ó {image.size[1]} pixels")
        
        return True, {
            'type': 'image',
            'filename': uploaded_file.name,
            'image': image,
            'original_data': uploaded_file.getvalue()
        }
        
    except Exception as e:
        st.error(f"‚ùå Erreur lecture image : {e}")
        return False, None

def traiter_pdf_simple(uploaded_file):
    """Traite les PDFs avec alternatives simples"""
    
    st.markdown("#### üìÑ PDF d√©tect√©")
    
    pdf_data = uploaded_file.getvalue()
    file_size_mb = len(pdf_data) / (1024 * 1024)
    
    # D√©tection du nombre de pages
    num_pages = get_pdf_page_count(pdf_data)
    
    if num_pages > 1:
        st.info(f"üìÑ PDF avec {num_pages} pages d√©tect√©")
        selected_page = st.selectbox(
            "Choisissez la page √† importer :",
            range(1, num_pages + 1),
            index=0,
            key=f"pdf_page_select_{uploaded_file.name}_{len(uploaded_file.getvalue())}",
            help="S√©lectionnez la page contenant l'ECG √† analyser"
        )
        page_index = selected_page - 1  # Conversion en index 0-based
    else:
        st.info("üìÑ PDF mono-page d√©tect√©")
        page_index = 0
    
    # Tentative de conversion automatique
    with st.spinner(f"üîÑ Conversion de la page {page_index + 1}..."):
        conversion_result = try_convert_pdf(pdf_data, page_index)
    
    if conversion_result['success']:
        st.success(f"‚úÖ {conversion_result['message']}")
        st.image(conversion_result['image'], caption=f"PDF converti - Page {page_index + 1}", use_container_width=True)
        
        return True, {
            'type': 'pdf_converted',
            'filename': uploaded_file.name,
            'image': conversion_result['image'],
            'method': conversion_result['method'],
            'page': page_index + 1
        }
    else:
        st.warning("‚ö†Ô∏è Conversion automatique √©chou√©e")
        st.info("üí° Interface de capture disponible ci-dessous")
        
        return True, {
            'type': 'pdf_manual' if file_size_mb <= 2 else 'pdf_large',
            'filename': uploaded_file.name,
            'data': pdf_data,
            'size_mb': file_size_mb,
            'page': page_index + 1
        }

def get_pdf_page_count(pdf_data):
    """Obtient le nombre de pages d'un PDF"""
    
    # Essai PyMuPDF
    try:
        import fitz
        pdf_doc = fitz.open(stream=pdf_data, filetype="pdf")
        page_count = pdf_doc.page_count
        pdf_doc.close()
        return page_count
    except ImportError:
        pass
    except Exception:
        pass
    
    # Essai pdfplumber
    try:
        import pdfplumber
        with pdfplumber.open(io.BytesIO(pdf_data)) as pdf:
            return len(pdf.pages)
    except ImportError:
        pass
    except Exception:
        pass
    
    # Fallback - assumer 1 page
    return 1

def try_convert_pdf(pdf_data, page_index=0):
    """Essaie de convertir le PDF √† la page sp√©cifi√©e"""
    
    # Essai PyMuPDF
    try:
        import fitz
        
        pdf_doc = fitz.open(stream=pdf_data, filetype="pdf")
        
        # V√©rifier que la page existe
        if page_index >= pdf_doc.page_count:
            page_index = 0
        
        page = pdf_doc[page_index]
        mat = fitz.Matrix(2.0, 2.0)
        pix = page.get_pixmap(matrix=mat)
        img_data = pix.tobytes("png")
        image = Image.open(io.BytesIO(img_data))
        pdf_doc.close()
        
        return {
            'success': True,
            'image': image,
            'message': f'Conversion PyMuPDF r√©ussie (page {page_index + 1})',
            'method': 'pymupdf'
        }
        
    except ImportError:
        pass
    except Exception:
        pass
    
    # Essai pdfplumber
    try:
        import pdfplumber
        
        with pdfplumber.open(io.BytesIO(pdf_data)) as pdf:
            # V√©rifier que la page existe
            if page_index >= len(pdf.pages):
                page_index = 0
            
            page = pdf.pages[page_index]
            image = page.to_image(resolution=200)
            pil_image = image.original
            
        return {
            'success': True,
            'image': pil_image,
            'message': f'Conversion pdfplumber r√©ussie (page {page_index + 1})',
            'method': 'pdfplumber'
        }
        
    except ImportError:
        pass
    except Exception:
        pass
    
    return {'success': False}

def traiter_xml_simple(uploaded_file):
    """Traite les fichiers XML"""
    
    try:
        xml_content = uploaded_file.getvalue().decode('utf-8')
        
        st.markdown("#### üìã XML ECG d√©tect√©")
        
        with st.expander("üìÑ Aper√ßu du contenu"):
            st.code(xml_content[:500], language='xml')
        
        return True, {
            'type': 'xml',
            'filename': uploaded_file.name,
            'content': xml_content,
            'original_data': uploaded_file.getvalue()
        }
        
    except Exception as e:
        st.error(f"‚ùå Erreur lecture XML : {e}")
        return False, None

def interface_recadrage_simple(file_data):
    """Interface de recadrage simplifi√©e"""
    
    if 'image' not in file_data:
        return None
    
    image = file_data['image']
    
    # Redimensionner pour l'affichage
    display_image = image.copy()
    max_width = 600
    
    if display_image.width > max_width:
        ratio = max_width / display_image.width
        new_height = int(display_image.height * ratio)
        display_image = display_image.resize((max_width, new_height), Image.Resampling.LANCZOS)
    
    # Initialiser les valeurs par d√©faut si pas encore d√©finies
    if "crop_x1" not in st.session_state:
        st.session_state.crop_x1 = 0
    if "crop_y1" not in st.session_state:
        st.session_state.crop_y1 = 0
    if "crop_x2" not in st.session_state:
        st.session_state.crop_x2 = display_image.width
    if "crop_y2" not in st.session_state:
        st.session_state.crop_y2 = display_image.height
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.markdown("#### üéØ Aper√ßu et zone de recadrage")
        
        # Curseurs de recadrage avec valeurs de session state
        x1 = st.slider("üîπ X d√©but", 0, display_image.width, st.session_state.crop_x1, key="x1")
        y1 = st.slider("üîπ Y d√©but", 0, display_image.height, st.session_state.crop_y1, key="y1") 
        x2 = st.slider("üîπ X fin", x1, display_image.width, st.session_state.crop_x2, key="x2")
        y2 = st.slider("üîπ Y fin", y1, display_image.height, st.session_state.crop_y2, key="y2")
        
        # Mettre √† jour les valeurs en session state
        st.session_state.crop_x1 = x1
        st.session_state.crop_y1 = y1
        st.session_state.crop_x2 = x2
        st.session_state.crop_y2 = y2
        
        # Aper√ßu de la zone recadr√©e
        if x2 > x1 and y2 > y1:
            cropped_preview = display_image.crop((x1, y1, x2, y2))
            st.image(cropped_preview, caption="Aper√ßu de la zone recadr√©e", use_container_width=True)
    
    with col2:
        st.markdown("#### ‚öôÔ∏è Contr√¥les")
        
        # Pr√©sets
        if st.button("ü´Ä ECG Standard", type="secondary", key="preset_ecg_standard"):
            # Recadrage typique (centre avec marges)
            margin = 50
            st.session_state.crop_x1 = margin
            st.session_state.crop_y1 = margin
            st.session_state.crop_x2 = display_image.width - margin
            st.session_state.crop_y2 = display_image.height - margin
            st.rerun()
        
        if st.button("üìÑ Image compl√®te", type="secondary", key="preset_full_image"):
            st.session_state.crop_x1 = 0
            st.session_state.crop_y1 = 0
            st.session_state.crop_x2 = display_image.width
            st.session_state.crop_y2 = display_image.height
            st.rerun()
        
        st.markdown("---")
        
        # Validation
        if st.button("‚úÖ Valider le recadrage", type="primary", key="validate_simple_crop"):
            # Utiliser les valeurs actuelles des sliders
            x1 = st.session_state.crop_x1 
            y1 = st.session_state.crop_y1
            x2 = st.session_state.crop_x2
            y2 = st.session_state.crop_y2
            
            # Calculer les coordonn√©es sur l'image originale
            scale_x = image.width / display_image.width
            scale_y = image.height / display_image.height
            
            real_x1 = int(x1 * scale_x)
            real_y1 = int(y1 * scale_y)
            real_x2 = int(x2 * scale_x)
            real_y2 = int(y2 * scale_y)
            
            # Recadrer l'image originale
            cropped_original = image.crop((real_x1, real_y1, real_x2, real_y2))
            
            st.success("‚úÖ Recadrage valid√© !")
            
            return {
                'type': 'image',
                'image': cropped_original,
                'coordinates': (real_x1, real_y1, real_x2, real_y2),
                'original_filename': file_data['filename']
            }
    
    return None

def guide_capture_pdf(file_data):
    """Guide pour capturer un PDF"""
    
    st.markdown("#### üì± Guide de capture d'√©cran")
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        # Viewer PDF.js avec page s√©lectionn√©e
        pdf_base64 = base64.b64encode(file_data['data']).decode()
        
        # Construire l'URL avec la page sp√©cifi√©e
        page_num = file_data.get('page', 1)
        viewer_url = f"https://mozilla.github.io/pdf.js/web/viewer.html?file=data:application/pdf;base64,{pdf_base64}#page={page_num}"
        
        viewer_html = f"""
        <div style="border: 2px solid #0066cc; border-radius: 10px; padding: 5px;">
            <iframe 
                src="{viewer_url}" 
                width="100%" 
                height="400" 
                style="border: none; border-radius: 5px;">
            </iframe>
        </div>
        """
        
        st.components.v1.html(viewer_html, height=420)
        
        if page_num > 1:
            st.info(f"üìÑ Affichage de la page {page_num}")
    
    with col2:
        st.markdown("#### üéØ Instructions")
        st.markdown("1. üì± **Windows+Shift+S**")
        st.markdown("2. üéØ **S√©lectionnez l'ECG**") 
        st.markdown("3. üíæ **Sauvegardez PNG/JPG**")
        st.markdown("4. üîÑ **Rechargez la page**")
        st.markdown("5. ‚¨ÜÔ∏è **R√©importez l'image**")
        
        if st.button("üîÑ J'ai captur√©, recharger", type="primary"):
            # Effacer la session pour recommencer
            for key in ['uploaded_file_data', 'cropped_ecg']:
                if key in st.session_state:
                    del st.session_state[key]
            st.rerun()

def interface_export_simple(cropped_data):
    """Interface d'export simplifi√©e"""
    
    # M√©tadonn√©es
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.image(cropped_data['image'], caption="ECG final √† exporter", use_container_width=True)
    
    with col2:
        st.markdown("#### üìä M√©tadonn√©es")
        
        case_id = st.text_input("ID du cas", value=f"ecg_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:8]}")
        age = st.number_input("√Çge patient", min_value=0, max_value=120, value=65)
        sexe = st.selectbox("Sexe", ["M", "F", "Non sp√©cifi√©"])
        contexte = st.text_area("Contexte", placeholder="Douleur thoracique...")
    
    if st.button("üöÄ Exporter vers la liseuse", type="primary"):
        success = executer_export_simple(case_id, cropped_data, {
            'age': age,
            'sexe': sexe, 
            'contexte': contexte
        })
        
        if success:
            st.success("üéâ ECG export√© avec succ√®s !")
            st.balloons()
            
            if st.button("‚ûï Importer un autre ECG"):
                for key in ['uploaded_file_data', 'cropped_ecg']:
                    if key in st.session_state:
                        del st.session_state[key]
                st.rerun()

def interface_export_xml_simple(file_data):
    """Export XML simple"""
    
    st.markdown("#### üìã Export de donn√©es XML")
    
    case_id = st.text_input("ID du cas", value=f"xml_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:8]}")
    
    if st.button("üíæ Exporter XML", type="primary"):
        success = executer_export_xml_simple(case_id, file_data)
        
        if success:
            st.success("üéâ XML export√© avec succ√®s !")

def executer_export_simple(case_id, cropped_data, metadata):
    """Ex√©cute l'export simple avec gestion d'erreur robuste"""
    
    try:
        # V√©rifications pr√©liminaires
        if not case_id or not case_id.strip():
            st.error("‚ùå ID du cas invalide")
            return False
            
        if not cropped_data:
            st.error("‚ùå Aucune donn√©e d'image √† exporter")
            return False
            
        if 'image' not in cropped_data or cropped_data['image'] is None:
            st.error("‚ùå Image manquante dans les donn√©es")
            return False
        
        # Nettoyer l'ID du cas
        case_id = case_id.strip()
        
        # Cr√©er le r√©pertoire de destination
        export_dir = Path("data/ecg_cases") / case_id
        
        # S'assurer que le r√©pertoire parent existe
        export_dir.parent.mkdir(parents=True, exist_ok=True)
        export_dir.mkdir(parents=True, exist_ok=True)
        
        st.info(f"üìÅ Cr√©ation du cas dans : {export_dir.absolute()}")
        
        # Sauvegarder l'image
        filename = f"{case_id}.png"
        image_path = export_dir / filename
        
        # Sauvegarder avec gestion d'erreur
        try:
            cropped_data['image'].save(image_path, 'PNG', optimize=True, quality=95)
            st.success(f"‚úÖ Image sauvegard√©e : {filename}")
        except Exception as img_error:
            st.error(f"‚ùå Erreur sauvegarde image : {img_error}")
            return False
        
        # Pr√©parer les m√©tadonn√©es avec valeurs par d√©faut
        metadata_json = {
            'case_id': case_id,
            'filename': filename,
            'created_date': datetime.now().isoformat(),
            'type': 'image',
            'age': metadata.get('age', 0),
            'sexe': metadata.get('sexe', 'Non sp√©cifi√©'),
            'contexte': metadata.get('contexte', 'ECG import√© pour analyse'),
            'diagnostic': '√Ä analyser',
            'statut': 'imported',
            'metadata': {
                'source_file': cropped_data.get('original_filename', 'fichier_source_inconnu'),
                'import_method': 'smart_importer_simple',
                'crop_coordinates': cropped_data.get('coordinates', None),
                'image_size': [cropped_data['image'].width, cropped_data['image'].height]
            }
        }
        
        # Sauvegarder les m√©tadonn√©es
        metadata_path = export_dir / 'metadata.json'
        try:
            with open(metadata_path, 'w', encoding='utf-8') as f:
                json.dump(metadata_json, f, indent=2, ensure_ascii=False)
            st.success(f"‚úÖ M√©tadonn√©es sauvegard√©es : metadata.json")
        except Exception as meta_error:
            st.error(f"‚ùå Erreur sauvegarde m√©tadonn√©es : {meta_error}")
            return False
        
        # V√©rifications finales
        if image_path.exists() and metadata_path.exists():
            st.success(f"üéâ Cas ECG cr√©√© avec succ√®s !")
            st.info(f"üÜî ID du cas : **{case_id}**")
            st.info(f"üìÇ Emplacement : `data/ecg_cases/{case_id}/`")
            st.info(f"üìã Fichiers cr√©√©s :")
            st.info(f"  ‚Ä¢ {filename} ({image_path.stat().st_size} bytes)")
            st.info(f"  ‚Ä¢ metadata.json ({metadata_path.stat().st_size} bytes)")
            return True
        else:
            st.error("‚ùå √âchec de v√©rification des fichiers cr√©√©s")
            return False
        
    except Exception as e:
        st.error(f"‚ùå Erreur g√©n√©rale export : {e}")
        st.error(f"üîç Type d'erreur : {type(e).__name__}")
        # Afficher plus de d√©tails en mode debug
        import traceback
        with st.expander("üêõ D√©tails de l'erreur (debug)"):
            st.code(traceback.format_exc())
        return False

def executer_export_xml_simple(case_id, file_data):
    """Export XML simple"""
    
    try:
        export_dir = Path("data/ecg_cases") / case_id
        export_dir.mkdir(parents=True, exist_ok=True)
        
        # Sauvegarder XML
        xml_path = export_dir / f"{case_id}.xml"
        with open(xml_path, 'w', encoding='utf-8') as f:
            f.write(file_data['content'])
        
        return True
        
    except Exception as e:
        st.error(f"‚ùå Erreur export XML : {e}")
        return False

if __name__ == "__main__":
    st.set_page_config(
        page_title="Import ECG Simple",
        page_icon="üì•",
        layout="wide"
    )
    
    st.title("üì• Import ECG Intelligent - Version Simple")
    smart_ecg_importer_simple()
